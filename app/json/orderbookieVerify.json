{
    "language":"Solidity",
    "sources":{
        "contracts/OrderBookie.sol":{
            "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./interfaces/IOrderBookie.sol\";\r\nimport \"./BookiesLibrary.sol\";\r\n\r\ncontract OrderBookie is IOrderBookie, SettlementManagerCallbackInterface, Modifiers\r\n{\r\n    using BookiesLibrary for ERC20;\r\n    using BookiesLibrary for string;\r\n\r\n    function _hasBet(uint256 index) private view {\r\n        require(bets[msg.sender].length != 0, \"Usage: You don\u0027t have a bet\");\r\n        require(index \u003c bets[msg.sender].length, \"Usage: Index out of range\");\r\n    }\r\n    modifier hasBet(uint256 index) {\r\n        _hasBet(index);\r\n        _;\r\n    }\r\n    /*  Constants variables    */\r\n    uint256 private constant MAX_ODD = 10000;\r\n    uint256 private constant MIN_ODD = 0;\r\n    uint256 private constant ODD_DECIMALS = 4;\r\n\r\n    /*  Public variables    */\r\n    uint256 public betMarket1Liquidity;\r\n    uint256 public betMarket2Liquidity;\r\n    address[] public bettors;\r\n\r\n    /*  Private Variables    */\r\n    ERC20 private accpetedToken_;\r\n    uint256 private immutable tokenDecimals;\r\n    OrderBookieInfo private bookieInfo_;\r\n\r\n    mapping(address =\u003e Bet[]) private bets; // Mapping of address to bet\r\n    mapping(uint256 =\u003e BetKey[]) private betMarket1; // Mapping of odd to bets that have not been matched to a counterparty bet\r\n    mapping(uint256 =\u003e BetKey[]) private betMarket2; // Mapping of odd to bets that have not been matched to a counterparty bet\r\n\r\n    constructor(bytes32 eventID,\r\n        uint256 startDate,\r\n        address owner,\r\n        address settlementManagerAddress,\r\n        address acceptedTokenAddress)\r\n    {\r\n        //TODO: Add checks\r\n        bookieInfo_ = OrderBookieInfo(eventID, UNSETTLED, startDate, false, owner, msg.sender, settlementManagerAddress, acceptedTokenAddress);\r\n\r\n        accpetedToken_ = ERC20(bookieInfo_.acceptedTokenAddress);\r\n        tokenDecimals = accpetedToken_.decimals();\r\n    }\r\n    \r\n    /**\r\n     * @notice Lets users place bets\r\n     */\r\n    function placeBetFor(address bettorAddr, int256 pick, uint256 stake, uint256 odd) override public notCanceled(bookieInfo_.isCanceled) beforeStart(bookieInfo_.startDate)\r\n    {\r\n        // Check if bet is valid\r\n        require(pick == OUTCOME2 || pick == OUTCOME1, \"Usage: Prediction has to be 1 or 0\");\r\n        require(stake \u003e 0, \"Usage: Wager amount has to be greater than 0\");\r\n        require(odd \u003e MIN_ODD \u0026\u0026 odd \u003c MAX_ODD, \"Usage: Odd has to be greater than 0 and less than 100\");\r\n        accpetedToken_.safeTransferFrom(msg.sender, address(this), stake);\r\n\r\n        uint256 toWin = stake * 10**tokenDecimals / (odd * 10**(tokenDecimals - ODD_DECIMALS)) - stake;\r\n\r\n        Bet memory bet = Bet(bettorAddr, pick, odd, stake, 0, toWin, 0, false);\r\n\r\n        // Set the counterpartyBetMarket and increment liquidity for market\r\n        mapping(uint256 =\u003e BetKey[]) storage counterpartyBetMarket = betMarket1;\r\n        if (pick == OUTCOME1) {\r\n            counterpartyBetMarket = betMarket2;\r\n            betMarket1Liquidity += stake;\r\n        }\r\n        else {\r\n            betMarket2Liquidity += stake;\r\n        }\r\n\r\n        BetKey[] storage availableBets = counterpartyBetMarket[MAX_ODD - odd]; // Have to flip the odd to get the counterparty odd\r\n\r\n        uint256 i = 0;\r\n        uint256 availableFunds;\r\n        uint256 counterpartyAvailableFunds;\r\n        uint256 amountNeeded;\r\n        uint256 counterpartyAmountNeeded;\r\n\r\n        // Check if there is available counterparty bets and bet still needs to be filled\r\n        while (availableBets.length != 0 \u0026\u0026 i \u003c availableBets.length \u0026\u0026 bet.toWinFilled \u003c bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) \r\n        {\r\n            // Match bet\r\n            BetKey memory counterpartyBetKey = availableBets[i++];\r\n\r\n            Bet storage counterpartyBet = bets[counterpartyBetKey.owner][counterpartyBetKey.index];\r\n\r\n            if (counterpartyBet.stakeUsed == counterpartyBet.stake || counterpartyBet.toWinFilled == counterpartyBet.toWin) // If counterparty bet is fully matched skip\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Calculate Available funds\r\n            availableFunds = bet.stake - bet.stakeUsed;\r\n            counterpartyAvailableFunds = counterpartyBet.stake - counterpartyBet.stakeUsed;\r\n\r\n            // Calculate Amount needed\r\n            amountNeeded = bet.toWin - bet.toWinFilled;\r\n            counterpartyAmountNeeded = counterpartyBet.toWin - counterpartyBet.toWinFilled;\r\n\r\n            /*\r\n            Since odds are inverse of each other there is a way to scale down the bets even \r\n            if they wager different amounts to where each side can fill each others bets. \r\n            This is done by scaling down the bet with the greater available funds to match \r\n            amount needed by the smaller bet. \r\n            */\r\n\r\n            // Counterparty has more funds than needed\r\n            if (availableFunds \u003c counterpartyAmountNeeded \u0026\u0026 counterpartyAvailableFunds \u003e amountNeeded) \r\n            {\r\n                counterpartyBet.stakeUsed += amountNeeded;\r\n                counterpartyBet.toWinFilled += availableFunds;\r\n\r\n                bet.stakeUsed += availableFunds;\r\n                bet.toWinFilled += amountNeeded;\r\n            }\r\n            else // Current bet has more funds than needed from counterparty\r\n            {\r\n                counterpartyBet.stakeUsed += counterpartyAvailableFunds;\r\n                counterpartyBet.toWinFilled += counterpartyAmountNeeded;\r\n\r\n                bet.stakeUsed += counterpartyAmountNeeded;\r\n                bet.toWinFilled += counterpartyAvailableFunds;\r\n            }\r\n        }\r\n\r\n        // Add new bettor\r\n        if (bets[bettorAddr].length == 0) {\r\n            bettors.push(bettorAddr);\r\n        }\r\n\r\n        // Add bet\r\n        bets[bettorAddr].push(bet);\r\n\r\n        // If unfilled, add to bet market and odd\r\n        if (bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) {\r\n            if (pick == OUTCOME1) {\r\n                betMarket1[odd].push(BetKey(bettorAddr, bets[bettorAddr].length - 1));\r\n            } \r\n            else {\r\n                betMarket2[odd].push(BetKey(bettorAddr, bets[bettorAddr].length - 1));\r\n            }   \r\n        }\r\n    }\r\n\r\n    function placeBet(int256 pick, uint256 stake, uint256 odd) override external {\r\n        placeBetFor(msg.sender, pick, stake, odd);\r\n    }\r\n\r\n    /**\r\n     * @notice Get bookie info\r\n     */\r\n    function getBookieInfo() override external view returns(OrderBookieInfo memory) \r\n    {\r\n        return bookieInfo_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets bets placed by address\r\n     */\r\n    function getBets(address addr) override external view returns(Bet[] memory bet)\r\n    {\r\n        return bets[addr];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets bettors\r\n     */\r\n    function getBettors() override external view returns(address[] memory) {\r\n        return bettors;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets total liquidity on pick\r\n     */\r\n    function getLiquiditySpread() override external view returns(uint256[2] memory liquidity) \r\n    {\r\n        return [betMarket1Liquidity, betMarket2Liquidity];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets open liquidity at odd\r\n     * @param pick Prediction\r\n     * @param odd Odd\r\n     */\r\n    function getOpenLiquidity(int256 pick, uint256 odd) override external view returns(uint256 liquidity) \r\n    {\r\n        require(pick == OUTCOME2 || pick == OUTCOME1, \"Usage: Prediction has to be 1 or 0\");\r\n        require(odd \u003e MIN_ODD \u0026\u0026 odd \u003c MAX_ODD, \"Usage: Odd has to be greater than 0 and less than 100\");\r\n\r\n        mapping(uint256 =\u003e BetKey[]) storage betMarket = betMarket2;\r\n        if (pick == OUTCOME1) {\r\n            betMarket = betMarket1;\r\n        }   \r\n\r\n        BetKey[] memory availableBets = betMarket[odd];\r\n\r\n        for (uint i = 0; i \u003c availableBets.length; i++) {\r\n            BetKey memory betKey = availableBets[i];\r\n            Bet memory bet = bets[betKey.owner][betKey.index];\r\n            liquidity += bet.stake - bet.stakeUsed;\r\n        }\r\n\r\n        return liquidity;\r\n    }\r\n\r\n    /** \r\n     * @notice Lets owner cancel bet\r\n     */\r\n    function cancelBookie() override external onlyOwner(bookieInfo_.owner) beforeStart(bookieInfo_.startDate) notCanceled(bookieInfo_.isCanceled)\r\n    {\r\n        require(bookieInfo_.result == UNSETTLED, \"Usage: Bookie has settled already\");\r\n        bookieInfo_.isCanceled = true;\r\n\r\n        // Pay out users\r\n        internalPayout();\r\n\r\n        emit BookiesLibrary.Canceled();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal payout function to pay out all the bettors\r\n     */\r\n    function internalPayout() private\r\n    {\r\n        // Payout bets\r\n        for (uint256 i = 0; i \u003c bettors.length; i++) {\r\n            address addr = bettors[i];\r\n            \r\n            Bet[] storage userBets = bets[addr];\r\n            uint256 unfilledAmount = 0;\r\n            uint256 totalPayout = 0;\r\n            for (uint256 j = 0; j \u003c userBets.length; j++) {\r\n                Bet storage bet = userBets[j];\r\n\r\n                if (bet.hasCollectedPayout) { // Skip if already collected\r\n                    continue;\r\n                }\r\n\r\n                // If bookie canceled, outcome was a tie or outcome is undisputable push bets\r\n                if (bookieInfo_.isCanceled || bookieInfo_.result == UNRESOLVABLE || bookieInfo_.result == TIE) {\r\n                    totalPayout += bet.stake;\r\n                } \r\n                else \r\n                {\r\n                    // Unfilled\r\n                    if (bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) {\r\n                        unfilledAmount += bet.stake - bet.stakeUsed;\r\n                    }\r\n\r\n                    if (bet.pick == bookieInfo_.result) // Filled\r\n                    {\r\n                        totalPayout += bet.toWinFilled + bet.stakeUsed;\r\n                    }\r\n                }\r\n                \r\n                bet.hasCollectedPayout = true;\r\n            }\r\n            \r\n            if (unfilledAmount \u003e 0 || totalPayout \u003e 0) {\r\n                accpetedToken_.safeTransfer(addr, unfilledAmount + totalPayout);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Lets users collect the unfilled bets once the event has started\r\n     */\r\n    function collectUnfilled(uint256 index) external notCanceled(bookieInfo_.isCanceled) hasBet(index)\r\n    {\r\n        Bet storage bet = bets[msg.sender][index];\r\n\r\n        require(bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake, \"Usage: Bet is already fully filled\");\r\n        require(!bet.hasCollectedPayout, \"Usage: Bet has already been collected\");\r\n\r\n        uint256 unfilledAmount = bet.stake - bet.stakeUsed;\r\n        bet.stake = bet.stakeUsed;\r\n        bet.toWin = bet.toWinFilled;\r\n\r\n        // Reduce liquidity\r\n        if (bet.pick == OUTCOME1) {\r\n            betMarket1Liquidity -= unfilledAmount;\r\n        } \r\n        else {\r\n            betMarket2Liquidity -= unfilledAmount;\r\n        }\r\n\r\n        accpetedToken_.safeTransfer(msg.sender, unfilledAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner withdraw all the orderbookie funds\r\n     */\r\n    function adminWithdraw() external onlyOwner(bookieInfo_.owner) hasSettled(bookieInfo_.result != UNSETTLED)\r\n    {\r\n        accpetedToken_.safeTransfer(bookieInfo_.owner, accpetedToken_.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner set the result of the event\r\n     */\r\n    function adminSettle(int256 result) external onlyOwner(bookieInfo_.owner) {\r\n        bookieInfo_.result = result;\r\n        emit BookiesLibrary.Settled();\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner payout all the bettors\r\n     */\r\n    function adminPayout() external onlyOwner(bookieInfo_.owner) notCanceled(bookieInfo_.isCanceled) hasSettled(bookieInfo_.result != UNSETTLED)\r\n    {\r\n        internalPayout();\r\n    }\r\n\r\n    /**\r\n     * @notice Call back function to settle orderbookie\r\n     */\r\n    function eventSettled(bytes32 eventID, int256 result) override external afterStarted(bookieInfo_.startDate) notCanceled(bookieInfo_.isCanceled)\r\n    {\r\n        require(eventID == bookieInfo_.eventID, \"Usage: EventID does not match\");\r\n        require(msg.sender == address(bookieInfo_.settlementManagerAddress), \"not authorized\");\r\n        require(bookieInfo_.result == UNSETTLED, \"Usage: Bookie has settled already\");\r\n\r\n        bookieInfo_.result = result;\r\n\r\n        internalPayout();\r\n        emit BookiesLibrary.Settled();\r\n    }\r\n}"
            }, 
        "contracts/interfaces/IOrderBookie.sol": {
            "content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\n\r\nstruct OrderBookieInfo \r\n{\r\n    bytes32 eventID;\r\n    int256 result;\r\n    uint256 startDate;\r\n    bool isCanceled;\r\n    address owner;\r\n    address factoryAddress;\r\n    address settlementManagerAddress;\r\n    address acceptedTokenAddress;\r\n}\r\n\r\nstruct Bet\r\n{\r\n    address owner;\r\n    int256 pick;\r\n    uint256 odd;\r\n    uint256 stake;\r\n    uint256 stakeUsed;\r\n    uint256 toWin;\r\n    uint256 toWinFilled;\r\n    bool hasCollectedPayout;\r\n}\r\n\r\nstruct BetKey\r\n{\r\n    address owner;\r\n    uint256 index;\r\n}\r\n\r\ninterface IOrderBookie \r\n{\r\n    function getBookieInfo() external view returns(OrderBookieInfo memory orderBookieInfo);\r\n    \r\n    function placeBet(int256 pick, uint256 stake, uint256 odd) external;\r\n\r\n    function placeBetFor(address payoutTo, int256 pick, uint256 stake, uint256 odd) external;\r\n\r\n    function getBets(address addr) external view returns(Bet[] memory);\r\n\r\n    function cancelBookie() external;\r\n\r\n    function collectUnfilled(uint256 index) external;\r\n\r\n    function getBettors() external view returns(address[] memory);\r\n\r\n    function getLiquiditySpread() external view returns(uint256[2] memory);\r\n\r\n    function getOpenLiquidity(int256 pick, uint256 odd) external view returns(uint256);\r\n}"
            },
        "contracts/BookiesLibrary.sol": {
            "content" : "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n// Outcome\r\nint256 constant OUTCOME1 = 0;\r\nint256 constant OUTCOME2 = 1e18;\r\nint256 constant TIE = 5e17;\r\nint256 constant UNRESOLVABLE = int256(57896044618658097711785492504343953926634992332820282019728);\r\nint256 constant UNSETTLED = -1e18;\r\nint256 constant TOO_EARLY = int256(-57896044618658097711785492504343953926634992332820282019728);\r\n\r\ninterface SettlementManagerCallbackInterface {\r\n     function eventSettled(bytes32 eventID, int256 result) external;\r\n}\r\n\r\ncontract Modifiers {\r\n    modifier onlyOwner(address owner) {\r\n        BookiesLibrary._onlyOwner(owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory(address factory) {\r\n        BookiesLibrary._onlyFactory(factory);\r\n        _;\r\n    }\r\n\r\n    modifier beforeStart(uint256 startDate) {\r\n        BookiesLibrary._beforeStart(startDate);\r\n        _;\r\n    }\r\n\r\n    modifier hasSettled(bool settled) {\r\n        BookiesLibrary._hasSettled(settled);\r\n        _;\r\n    }\r\n\r\n    modifier afterStarted(uint256 startDate) {\r\n        BookiesLibrary._afterStarted(startDate);\r\n        _;\r\n    }\r\n\r\n    modifier notCanceled(bool isCanceled) {\r\n        BookiesLibrary._notCanceled(isCanceled);\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary BookiesLibrary {\r\n    event Canceled();\r\n    event Started();\r\n    event Settled();\r\n\r\n    // Strings\r\n    function compareStrings(string calldata a, string calldata b) pure public returns (bool) \r\n    {         \r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n    // SafeERC20\r\n    function safeTransfer(ERC20 token, address to, uint256 amount) public {\r\n         require(token.transfer(to, amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 amount) public {\r\n        require(token.transferFrom(from, to, amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 amount) public {\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        require(token.approve(spender, allowance + amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    // Modifiers\r\n    function _onlyOwner(address owner) external view {\r\n        require(msg.sender == owner, \"Usage: Only owner can call\");\r\n    }\r\n\r\n    function _onlyFactory(address factory) external view {\r\n        require(msg.sender == factory, \"Usage: Only factory can call\");\r\n    }\r\n\r\n    function _beforeStart(uint256 startDate) external view {\r\n        require(block.timestamp \u003c startDate, \"Usage: Event has started\");\r\n    }\r\n\r\n    function _hasSettled(bool hasSettled) external pure {\r\n        require(hasSettled, \"Usage: Bookie has not settled\");\r\n    }\r\n\r\n    function _afterStarted(uint256 startDate) external view {\r\n        require(block.timestamp \u003e startDate, \"Usage: Bookie has not yet started\");\r\n    }\r\n\r\n    function _notCanceled(bool isCanceled) external pure {\r\n        require(!isCanceled, \"Usage: Bookie is canceled\");\r\n    }\r\n}"
            },
        "@openzeppelin/contracts/token/ERC20/IERC20.sol" : {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./extensions/IERC20Metadata.sol\";\r\nimport \"../../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it\u0027s overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount \u003c= accountBalance \u003c= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n"
            }
        },
    "settings":{"optimizer":{"enabled":true,"runs":200}, "viaIR": true, "libraries":{"contracts/BookiesLibrary.sol":{"BookiesLibrary":"0x14d3952d6617dedCe4Aa03D571154C404a8Ec45f"}}
    }
}