{
    "language":"Solidity",
    "sources":{
        "contracts/OrderBookie.sol":{
            "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./interfaces/IOrderBookie.sol\";\r\nimport \"./BookiesLibrary.sol\";\r\n\r\ncontract OrderBookie is IOrderBookie, SettlementManagerCallbackInterface, Modifiers\r\n{\r\n    using BookiesLibrary for ERC20;\r\n    using BookiesLibrary for string;\r\n\r\n    function _hasBet(uint256 index) private view {\r\n        require(bets[msg.sender].length != 0, \"Usage: You don\u0027t have a bet\");\r\n        require(index \u003c bets[msg.sender].length, \"Usage: Index out of range\");\r\n    }\r\n    modifier hasBet(uint256 index) {\r\n        _hasBet(index);\r\n        _;\r\n    }\r\n    /*  Constants variables    */\r\n    uint256 public constant MAX_ODD = 10000;\r\n    uint256 public constant MIN_ODD = 0;\r\n    uint256 public constant ODD_DECIMALS = 4;\r\n    uint256 public constant TX_FEE = 2;\r\n\r\n    /*  Public variables    */\r\n    uint256 public betMarket1Liquidity;\r\n    uint256 public betMarket2Liquidity;\r\n    address[] public bettors;\r\n    uint256 public immutable tokenDecimals;\r\n\r\n    /*  Private Variables    */\r\n    ERC20 private accpetedToken_;\r\n    OrderBookieInfo private bookieInfo_;\r\n\r\n    mapping(address =\u003e Bet[]) private bets; // Mapping of address to bet\r\n    mapping(uint256 =\u003e BetKey[]) private betMarket1; // Mapping of odd to bets that have not been matched to a counterparty bet\r\n    mapping(uint256 =\u003e BetKey[]) private betMarket2; // Mapping of odd to bets that have not been matched to a counterparty bet\r\n\r\n    constructor(bytes32 marketId,\r\n        uint256 startDate,\r\n        address owner,\r\n        address settlementManagerAddress,\r\n        address acceptedTokenAddress)\r\n    {\r\n        //TODO: Add checks\r\n        bookieInfo_ = OrderBookieInfo(marketId, UNSETTLED, startDate, false, owner, msg.sender, settlementManagerAddress, acceptedTokenAddress, TX_FEE);\r\n\r\n        accpetedToken_ = ERC20(bookieInfo_.acceptedTokenAddress);\r\n        tokenDecimals = accpetedToken_.decimals();\r\n    }\r\n    \r\n    /**\r\n     * @notice Lets users place bets\r\n     */\r\n    function placeBetFor(address bettorAddr, int256 pick, uint256 stake, uint256 odd) override public notCanceled(bookieInfo_.isCanceled) beforeStart(bookieInfo_.startDate)\r\n    {\r\n        // Check if bet is valid\r\n        require(pick == OUTCOME2 || pick == OUTCOME1, \"Usage: Prediction has to be 1 or 0\");\r\n        require(stake \u003e 0, \"Usage: Wager amount has to be greater than 0\");\r\n        require(odd \u003e MIN_ODD \u0026\u0026 odd \u003c MAX_ODD, \"Usage: Odd has to be greater than 0 and less than 100\");\r\n        accpetedToken_.safeTransferFrom(msg.sender, address(this), stake);\r\n\r\n        uint256 toWin = stake * 10**tokenDecimals / (odd * 10**(tokenDecimals - ODD_DECIMALS)) - stake;\r\n\r\n        Bet memory bet = Bet(bettorAddr, block.timestamp, pick, odd, stake, 0, toWin, 0, false);\r\n\r\n        // Set the counterpartyBetMarket and increment liquidity for market\r\n        mapping(uint256 =\u003e BetKey[]) storage counterpartyBetMarket = betMarket1;\r\n        if (pick == OUTCOME1) {\r\n            counterpartyBetMarket = betMarket2;\r\n            betMarket1Liquidity += stake;\r\n        }\r\n        else {\r\n            betMarket2Liquidity += stake;\r\n        }\r\n\r\n        BetKey[] storage availableBets = counterpartyBetMarket[MAX_ODD - odd]; // Have to flip the odd to get the counterparty odd\r\n\r\n        uint256 i = 0;\r\n        uint256 availableFunds;\r\n        uint256 counterpartyAvailableFunds;\r\n        uint256 amountNeeded;\r\n        uint256 counterpartyAmountNeeded;\r\n\r\n        // Check if there is available counterparty bets and bet still needs to be filled\r\n        while (availableBets.length != 0 \u0026\u0026 i \u003c availableBets.length \u0026\u0026 bet.toWinFilled \u003c bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) \r\n        {\r\n            // Match bet\r\n            BetKey memory counterpartyBetKey = availableBets[i++];\r\n\r\n            Bet storage counterpartyBet = bets[counterpartyBetKey.owner][counterpartyBetKey.index];\r\n\r\n            if (counterpartyBet.stakeUsed == counterpartyBet.stake || counterpartyBet.toWinFilled == counterpartyBet.toWin) // If counterparty bet is fully matched skip\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Calculate Available funds\r\n            availableFunds = bet.stake - bet.stakeUsed;\r\n            counterpartyAvailableFunds = counterpartyBet.stake - counterpartyBet.stakeUsed;\r\n\r\n            // Calculate Amount needed\r\n            amountNeeded = bet.toWin - bet.toWinFilled;\r\n            counterpartyAmountNeeded = counterpartyBet.toWin - counterpartyBet.toWinFilled;\r\n\r\n            /*\r\n            Since odds are inverse of each other there is a way to scale down the bets even \r\n            if they wager different amounts to where each side can fill each others bets. \r\n            This is done by scaling down the bet with the greater available funds to match \r\n            amount needed by the smaller bet. \r\n            */\r\n\r\n            // Counterparty has more funds than needed\r\n            if (availableFunds \u003c counterpartyAmountNeeded \u0026\u0026 counterpartyAvailableFunds \u003e amountNeeded) \r\n            {\r\n                counterpartyBet.stakeUsed += amountNeeded;\r\n                counterpartyBet.toWinFilled += availableFunds;\r\n\r\n                bet.stakeUsed += availableFunds;\r\n                bet.toWinFilled += amountNeeded;\r\n            }\r\n            else // Current bet has more funds than needed from counterparty\r\n            {\r\n                counterpartyBet.stakeUsed += counterpartyAvailableFunds;\r\n                counterpartyBet.toWinFilled += counterpartyAmountNeeded;\r\n\r\n                bet.stakeUsed += counterpartyAmountNeeded;\r\n                bet.toWinFilled += counterpartyAvailableFunds;\r\n            }\r\n        }\r\n\r\n        // Add new bettor\r\n        if (bets[bettorAddr].length == 0) {\r\n            bettors.push(bettorAddr);\r\n        }\r\n\r\n        // Add bet\r\n        bets[bettorAddr].push(bet);\r\n\r\n        // If unfilled, add to bet market and odd\r\n        if (bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) {\r\n            if (pick == OUTCOME1) {\r\n                betMarket1[odd].push(BetKey(bettorAddr, bets[bettorAddr].length - 1));\r\n            } \r\n            else {\r\n                betMarket2[odd].push(BetKey(bettorAddr, bets[bettorAddr].length - 1));\r\n            }   \r\n        }\r\n\r\n        // Emit market\r\n        emit PlacedBet(bettorAddr, pick, stake, odd, bet.timestamp);\r\n    }\r\n\r\n    function placeBet(int256 pick, uint256 stake, uint256 odd) override external {\r\n        placeBetFor(msg.sender, pick, stake, odd);\r\n    }\r\n\r\n    /**\r\n     * @notice Get bookie info\r\n     */\r\n    function getBookieInfo() override external view returns(OrderBookieInfo memory) \r\n    {\r\n        return bookieInfo_;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets bets placed by address\r\n     */\r\n    function getBets(address addr) override external view returns(Bet[] memory bet)\r\n    {\r\n        return bets[addr];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets bettors\r\n     */\r\n    function getBettors() override external view returns(address[] memory) {\r\n        return bettors;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets total liquidity on pick\r\n     */\r\n    function getLiquiditySpread() override external view returns(uint256[2] memory liquidity) \r\n    {\r\n        return [betMarket1Liquidity, betMarket2Liquidity];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets open liquidity at odd\r\n     * @param pick Prediction\r\n     * @param odd Odd\r\n     */\r\n    function getOpenLiquidity(int256 pick, uint256 odd) override external view returns(uint256 liquidity) \r\n    {\r\n        require(pick == OUTCOME2 || pick == OUTCOME1, \"Usage: Prediction has to be 1 or 0\");\r\n        require(odd \u003e MIN_ODD \u0026\u0026 odd \u003c MAX_ODD, \"Usage: Odd has to be greater than 0 and less than 100\");\r\n\r\n        mapping(uint256 =\u003e BetKey[]) storage betMarket = betMarket2;\r\n        if (pick == OUTCOME1) {\r\n            betMarket = betMarket1;\r\n        }   \r\n\r\n        BetKey[] memory availableBets = betMarket[odd];\r\n\r\n        for (uint i = 0; i \u003c availableBets.length; i++) {\r\n            BetKey memory betKey = availableBets[i];\r\n            Bet memory bet = bets[betKey.owner][betKey.index];\r\n            liquidity += bet.stake - bet.stakeUsed;\r\n        }\r\n\r\n        return liquidity;\r\n    }\r\n\r\n    /** \r\n     * @notice Lets owner cancel bet\r\n     */\r\n    function cancelBookie() override external onlyOwner(bookieInfo_.owner) beforeStart(bookieInfo_.startDate) notCanceled(bookieInfo_.isCanceled)\r\n    {\r\n        require(bookieInfo_.result == UNSETTLED, \"Usage: Bookie has settled already\");\r\n        bookieInfo_.isCanceled = true;\r\n\r\n        // Pay out users\r\n        internalPayout();\r\n\r\n        emit Canceled();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal payout function to pay out all the bettors\r\n     */\r\n    function internalPayout() private\r\n    {\r\n        // Payout bets\r\n        for (uint256 i = 0; i \u003c bettors.length; i++) {\r\n            address addr = bettors[i];\r\n            \r\n            Bet[] storage userBets = bets[addr];\r\n            uint256 unfilledAmount = 0;\r\n            uint256 totalPayout = 0;\r\n            for (uint256 j = 0; j \u003c userBets.length; j++) {\r\n                Bet storage bet = userBets[j];\r\n\r\n                if (bet.hasCollectedPayout) { // Skip if already collected\r\n                    continue;\r\n                }\r\n\r\n                // If bookie canceled, outcome was a tie or outcome is undisputable push bets\r\n                if (bookieInfo_.isCanceled || bookieInfo_.result == UNRESOLVABLE || bookieInfo_.result == TIE) {\r\n                    totalPayout += bet.stake;\r\n                } \r\n                else \r\n                {\r\n                    // Unfilled\r\n                    if (bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake) {\r\n                        unfilledAmount += bet.stake - bet.stakeUsed;\r\n                    }\r\n\r\n                    if (bet.pick == bookieInfo_.result) // Filled\r\n                    {\r\n                        uint256 toWinFilled = bet.toWinFilled * (100 - bookieInfo_.txFee) / 100;\r\n                        totalPayout += toWinFilled + bet.stakeUsed;\r\n                    }\r\n                }\r\n                \r\n                bet.hasCollectedPayout = true;\r\n            }\r\n            \r\n            if (unfilledAmount \u003e 0 || totalPayout \u003e 0) {\r\n                accpetedToken_.safeTransfer(addr, unfilledAmount + totalPayout);\r\n            }\r\n        }\r\n\r\n        // Pay left over funds to owner\r\n        accpetedToken_.safeTransfer(bookieInfo_.owner, accpetedToken_.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice Lets users collect the unfilled bets once the market has started\r\n     */\r\n    function collectUnfilled(uint256 index) external notCanceled(bookieInfo_.isCanceled) hasBet(index)\r\n    {\r\n        Bet storage bet = bets[msg.sender][index];\r\n\r\n        require(bet.toWinFilled != bet.toWin \u0026\u0026 bet.stakeUsed != bet.stake, \"Usage: Bet is already fully filled\");\r\n        require(!bet.hasCollectedPayout, \"Usage: Bet has already been collected\");\r\n\r\n        uint256 unfilledAmount = bet.stake - bet.stakeUsed;\r\n        bet.stake = bet.stakeUsed;\r\n        bet.toWin = bet.toWinFilled;\r\n\r\n        // Reduce liquidity\r\n        if (bet.pick == OUTCOME1) {\r\n            betMarket1Liquidity -= unfilledAmount;\r\n        } \r\n        else {\r\n            betMarket2Liquidity -= unfilledAmount;\r\n        }\r\n\r\n        accpetedToken_.safeTransfer(msg.sender, unfilledAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner withdraw all the orderbookie funds\r\n     */\r\n    function adminWithdraw() external onlyOwner(bookieInfo_.owner) hasSettled(bookieInfo_.result != UNSETTLED)\r\n    {\r\n        accpetedToken_.safeTransfer(bookieInfo_.owner, accpetedToken_.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner set the result of the market\r\n     */\r\n    function adminSettle(int256 result) external onlyOwner(bookieInfo_.owner) {\r\n        bookieInfo_.result = result;\r\n        emit Settled(result);\r\n    }\r\n\r\n    /**\r\n     * @notice Lets owner payout all the bettors\r\n     */\r\n    function adminPayout() external onlyOwner(bookieInfo_.owner) notCanceled(bookieInfo_.isCanceled) hasSettled(bookieInfo_.result != UNSETTLED)\r\n    {\r\n        internalPayout();\r\n    }\r\n\r\n    /**\r\n     * @notice Call back function to settle orderbookie\r\n     */\r\n    function marketSettled(bytes32 marketId, int256 result) override external afterStarted(bookieInfo_.startDate) notCanceled(bookieInfo_.isCanceled)\r\n    {\r\n        require(marketId == bookieInfo_.marketId, \"Usage: marketID does not match\");\r\n        require(msg.sender == address(bookieInfo_.settlementManagerAddress), \"not authorized\");\r\n        require(bookieInfo_.result == UNSETTLED, \"Usage: Bookie has settled already\");\r\n\r\n        bookieInfo_.result = result;\r\n\r\n        internalPayout();\r\n        emit Settled(result);\r\n    }\r\n}"
            }, 
        "contracts/interfaces/IOrderBookie.sol": {
            "content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\n\r\nstruct OrderBookieInfo \r\n{\r\n    bytes32 marketId;\r\n    int256 result;\r\n    uint256 startDate;\r\n    bool isCanceled;\r\n    address owner;\r\n    address factoryAddress;\r\n    address settlementManagerAddress;\r\n    address acceptedTokenAddress;\r\n    uint256 txFee;\r\n}\r\n\r\nstruct Bet\r\n{\r\n    address owner;\r\n    uint256 timestamp;\r\n    int256 pick;\r\n    uint256 odd;\r\n    uint256 stake;\r\n    uint256 stakeUsed;\r\n    uint256 toWin;\r\n    uint256 toWinFilled;\r\n    bool hasCollectedPayout;\r\n}\r\n\r\nstruct BetKey\r\n{\r\n    address owner;\r\n    uint256 index;\r\n}\r\n\r\ninterface IOrderBookie \r\n{\r\n    event Canceled();\r\n    event Started();\r\n    event Settled(int256 result);\r\n    event PlacedBet(address indexed bettor, int256 pick, uint256 stake, uint256 odd, uint256 timeStamp);\r\n\r\n    function getBookieInfo() external view returns(OrderBookieInfo memory orderBookieInfo);\r\n    \r\n    function placeBet(int256 pick, uint256 stake, uint256 odd) external;\r\n\r\n    function placeBetFor(address payoutTo, int256 pick, uint256 stake, uint256 odd) external;\r\n\r\n    function getBets(address addr) external view returns(Bet[] memory);\r\n\r\n    function cancelBookie() external;\r\n\r\n    function collectUnfilled(uint256 index) external;\r\n\r\n    function getBettors() external view returns(address[] memory);\r\n\r\n    function getLiquiditySpread() external view returns(uint256[2] memory);\r\n\r\n    function getOpenLiquidity(int256 pick, uint256 odd) external view returns(uint256);\r\n}"
            },
        "contracts/BookiesLibrary.sol": {
            "content" : "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// Outcome\r\nint256 constant OUTCOME1 = 0;\r\nint256 constant OUTCOME2 = 1e18;\r\nint256 constant TIE = 5e17;\r\nint256 constant UNRESOLVABLE = int256(57896044618658097711785492504343953926634992332820282019728);\r\nint256 constant UNSETTLED = -1e18;\r\nint256 constant TOO_EARLY = int256(-57896044618658097711785492504343953926634992332820282019728);\r\n\r\ninterface SettlementManagerCallbackInterface {\r\n     function marketSettled(bytes32 marketId, int256 result) external;\r\n}\r\n\r\ninterface ERC20 is IERC20 {\r\n    function decimals() external view returns (uint8 decimalPlaces);\r\n    function symbol() external view returns (string memory tokenSymbol);\r\n}\r\n\r\ncontract Modifiers {\r\n    modifier onlyOwner(address owner) {\r\n        BookiesLibrary._onlyOwner(owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory(address factory) {\r\n        BookiesLibrary._onlyFactory(factory);\r\n        _;\r\n    }\r\n\r\n    modifier beforeStart(uint256 startDate) {\r\n        BookiesLibrary._beforeStart(startDate);\r\n        _;\r\n    }\r\n\r\n    modifier hasSettled(bool settled) {\r\n        BookiesLibrary._hasSettled(settled);\r\n        _;\r\n    }\r\n\r\n    modifier afterStarted(uint256 startDate) {\r\n        BookiesLibrary._afterStarted(startDate);\r\n        _;\r\n    }\r\n\r\n    modifier notCanceled(bool isCanceled) {\r\n        BookiesLibrary._notCanceled(isCanceled);\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary BookiesLibrary {\r\n    // Strings\r\n    function compareStrings(string calldata a, string calldata b) pure public returns (bool) \r\n    {         \r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n    // SafeERC20\r\n    function safeTransfer(ERC20 token, address to, uint256 amount) public {\r\n         require(token.transfer(to, amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 amount) public {\r\n        require(token.transferFrom(from, to, amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 amount) public {\r\n        uint256 allowance = token.allowance(address(this), spender);\r\n        require(token.approve(spender, allowance + amount), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    // Modifiers\r\n    function _onlyOwner(address owner) external view {\r\n        require(msg.sender == owner, \"Usage: Only owner can call\");\r\n    }\r\n\r\n    function _onlyFactory(address factory) external view {\r\n        require(msg.sender == factory, \"Usage: Only factory can call\");\r\n    }\r\n\r\n    function _beforeStart(uint256 startDate) external view {\r\n        require(block.timestamp \u003c startDate, \"Usage: Event has started\");\r\n    }\r\n\r\n    function _hasSettled(bool hasSettled) external pure {\r\n        require(hasSettled, \"Usage: Bookie has not settled\");\r\n    }\r\n\r\n    function _afterStarted(uint256 startDate) external view {\r\n        require(block.timestamp \u003e startDate, \"Usage: Bookie has not yet started\");\r\n    }\r\n\r\n    function _notCanceled(bool isCanceled) external pure {\r\n        require(!isCanceled, \"Usage: Bookie is canceled\");\r\n    }\r\n}"
            },
        "@openzeppelin/contracts/token/ERC20/IERC20.sol" : {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n"
            }
        },
    "settings":{"optimizer":{"enabled":true,"runs":200}, "viaIR": true, "libraries":{"contracts/BookiesLibrary.sol":{"BookiesLibrary":"0x46a2E9187f38e51Af9149C0CB62bEEC9c565BD43"}}
    }
}